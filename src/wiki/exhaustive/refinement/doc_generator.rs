//! Natural Document Generator
//!
//! Generates rich, contextual documentation from domain insights.
//! Content-first approach: AI-generated markdown is used directly.

use crate::types::error::WeaveError;
use crate::wiki::exhaustive::consolidation::DomainInsight;
use std::path::Path;

use super::quality_scorer::{GapReport, QualityReport, QualityScore, QualityScorer};

/// Document generator for final wiki output
pub struct DocGenerator {
    output_dir: std::path::PathBuf,
}

impl DocGenerator {
    pub fn new(output_dir: impl AsRef<Path>) -> Self {
        Self {
            output_dir: output_dir.as_ref().to_path_buf(),
        }
    }

    /// Sanitize domain name for use as filename
    fn sanitize_domain_name(name: &str) -> String {
        name.to_lowercase()
            .replace(" & ", "-and-")
            .replace('&', "-and-")
            .replace([' ', '/', '\\', '_'], "-")
            .chars()
            .filter(|c| c.is_alphanumeric() || *c == '-')
            .collect::<String>()
            .trim_matches('-')
            .to_string()
    }

    /// Generate complete documentation
    pub async fn generate(&self, domains: &[DomainInsight]) -> Result<Vec<String>, WeaveError> {
        let mut generated_files = vec![];

        for domain in domains {
            let file_path = self.generate_domain_page(domain).await?;
            generated_files.push(file_path);
        }

        let index_path = self.generate_index(domains).await?;
        generated_files.push(index_path);

        Ok(generated_files)
    }

    /// Generate domain page with rich content
    async fn generate_domain_page(&self, domain: &DomainInsight) -> Result<String, WeaveError> {
        let mut output = String::new();

        // Header with natural description
        output.push_str(&format!("# {}\n\n", domain.name));

        // Relevant Source Files (DeepWiki pattern - collapsible section)
        if !domain.files.is_empty() {
            output.push_str("<details>\n<summary>Relevant source files</summary>\n\n");
            output.push_str(
                "The following files were used as context for generating this wiki page:\n\n",
            );
            for file in &domain.files {
                output.push_str(&format!("- [{}]({})\n", file, file));
            }
            output.push_str("\n</details>\n\n");
        }

        // Scope statement (description)
        if !domain.description.is_empty() {
            output.push_str(&domain.description);
            output.push_str("\n\n");
        }

        // Navigation hints - Related files as links
        if !domain.related_files.is_empty() {
            output.push_str("**See also:** ");
            for rel in domain.related_files.iter().take(5) {
                let filename = std::path::Path::new(&rel.path)
                    .file_stem()
                    .and_then(|s| s.to_str())
                    .unwrap_or(&rel.path);
                output.push_str(&format!("[{}]({}.md) ", filename, filename));
            }
            output.push_str("\n\n");
        }

        // Primary diagram (if available)
        if let Some(ref diagram) = domain.diagram {
            output.push_str("```mermaid\n");
            output.push_str(diagram);
            output.push_str("\n```\n\n");
        }

        // Rich markdown content (AI-generated)
        if !domain.content.is_empty() {
            output.push_str(&domain.content);
            output.push_str("\n\n");
        }

        // Documentation gaps (if any)
        if !domain.gaps.is_empty() {
            output.push_str("## Documentation Gaps\n\n");
            for gap in &domain.gaps {
                output.push_str(&format!("- {}\n", gap));
            }
            output.push('\n');
        }

        // Sources footer (compact format)
        if !domain.files.is_empty() {
            output.push_str("---\n\n");
            output.push_str("**Sources:** ");
            for file in domain.files.iter().take(5) {
                output.push_str(&format!("[{}]({}) ", file, file));
            }
            if domain.files.len() > 5 {
                output.push_str(&format!("and {} more", domain.files.len() - 5));
            }
            output.push_str("\n\n");
        }

        // Footer
        output.push_str("---\n\n");
        output.push_str("*Generated by WeaveWiki*\n");

        // Write file
        let sanitized_name = Self::sanitize_domain_name(&domain.name);
        let filename = format!("{}.md", sanitized_name);
        let path = self.output_dir.join("domains").join(&filename);

        if let Some(parent) = path.parent() {
            tokio::fs::create_dir_all(parent).await?;
        }

        tokio::fs::write(&path, output).await?;
        Ok(path.to_string_lossy().to_string())
    }

    /// Generate index page
    async fn generate_index(&self, domains: &[DomainInsight]) -> Result<String, WeaveError> {
        let mut content = String::new();

        content.push_str("# Project Documentation\n\n");

        // Overview
        let total_files: usize = domains.iter().map(|d| d.files.len()).sum();
        let total_words: usize = domains.iter().map(|d| d.content_word_count()).sum();

        content.push_str("## Overview\n\n");
        content.push_str(&format!(
            "This documentation covers **{} domains** containing **{} source files** with **{} words** of documentation.\n\n",
            domains.len(),
            total_files,
            total_words
        ));

        // Domain list sorted by importance then file count
        content.push_str("## Domains\n\n");

        let mut sorted_domains: Vec<_> = domains.iter().collect();
        sorted_domains.sort_by(|a, b| {
            b.importance
                .cmp(&a.importance)
                .then_with(|| b.files.len().cmp(&a.files.len()))
        });

        for domain in sorted_domains {
            let sanitized_name = Self::sanitize_domain_name(&domain.name);
            let filename = format!("{}.md", sanitized_name);
            let importance_badge = match domain.importance {
                crate::wiki::exhaustive::types::Importance::Critical => " ðŸ”´",
                crate::wiki::exhaustive::types::Importance::High => " ðŸŸ ",
                _ => "",
            };

            content.push_str(&format!(
                "### [{}](domains/{}){}\n\n",
                domain.name, filename, importance_badge
            ));

            // Brief description
            let brief = domain
                .description
                .split('.')
                .next()
                .unwrap_or(&domain.description);
            if !brief.is_empty() {
                content.push_str(&format!("{}\n\n", brief));
            }

            content.push_str(&format!(
                "- **Files:** {} | **Words:** {}\n\n",
                domain.files.len(),
                domain.content_word_count()
            ));
        }

        // Footer
        content.push_str("---\n\n");
        content.push_str(&format!(
            "*Generated by WeaveWiki v{}*\n",
            env!("CARGO_PKG_VERSION")
        ));

        let path = self.output_dir.join("index.md");
        tokio::fs::write(&path, content).await?;
        Ok(path.to_string_lossy().to_string())
    }

    /// Generate coverage report
    pub async fn generate_coverage_report(
        &self,
        domains: &[DomainInsight],
        quality_score: &QualityScore,
        quality_target: f32,
        refinement_turns: u8,
    ) -> Result<String, WeaveError> {
        let report = QualityReport {
            overall_score: quality_score.overall(),
            target_score: quality_target,
            category_scores: quality_score.clone(),
            gaps: self.identify_gaps(domains, quality_score),
            refinement_turns_used: refinement_turns,
            recommendation: self.generate_recommendation(quality_score, quality_target),
        };

        let content = report.to_markdown();
        let path = self.output_dir.join("_coverage.md");
        tokio::fs::write(&path, content).await?;
        Ok(path.to_string_lossy().to_string())
    }

    /// Generate quality report
    pub fn generate_quality_report(
        &self,
        domains: &[DomainInsight],
        quality_target: f32,
        refinement_turns: u8,
    ) -> QualityReport {
        let scorer = QualityScorer::new();
        let quality_score = scorer.score(domains);

        QualityReport {
            overall_score: quality_score.overall(),
            target_score: quality_target,
            category_scores: quality_score.clone(),
            gaps: self.identify_gaps(domains, &quality_score),
            refinement_turns_used: refinement_turns,
            recommendation: self.generate_recommendation(&quality_score, quality_target),
        }
    }

    /// Identify documentation gaps
    fn identify_gaps(
        &self,
        domains: &[DomainInsight],
        quality_score: &QualityScore,
    ) -> Vec<GapReport> {
        let mut gaps = vec![];
        let threshold = 0.70;

        if quality_score.content_coverage < threshold {
            gaps.push(GapReport {
                category: "Content Coverage".to_string(),
                current_score: quality_score.content_coverage,
                files: domains
                    .iter()
                    .filter(|d| !d.has_content())
                    .flat_map(|d| d.files.iter().take(3).cloned())
                    .collect(),
            });
        }

        if quality_score.diagram_coverage < threshold {
            gaps.push(GapReport {
                category: "Diagram Coverage".to_string(),
                current_score: quality_score.diagram_coverage,
                files: domains
                    .iter()
                    .filter(|d| d.diagram.is_none())
                    .flat_map(|d| d.files.iter().take(2).cloned())
                    .collect(),
            });
        }

        if quality_score.relationships < threshold {
            gaps.push(GapReport {
                category: "Cross-References".to_string(),
                current_score: quality_score.relationships,
                files: domains
                    .iter()
                    .filter(|d| d.related_files.is_empty())
                    .flat_map(|d| d.files.iter().take(2).cloned())
                    .collect(),
            });
        }

        gaps
    }

    /// Generate recommendation based on scores
    fn generate_recommendation(&self, score: &QualityScore, target: f32) -> String {
        let overall = score.overall();

        if overall >= target {
            "Target quality achieved. Documentation is complete.".to_string()
        } else if overall >= target * 0.9 {
            "Nearly at target. Consider one more refinement turn.".to_string()
        } else if overall >= target * 0.7 {
            "Good progress. Continue refinement to reach target.".to_string()
        } else {
            "Significant gaps remain. Review identified areas.".to_string()
        }
    }
}
