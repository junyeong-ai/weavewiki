//! Generate architecture documentation from Top-Down analysis results
//! Integrates ProjectInsight into final wiki output

use crate::wiki::exhaustive::characterization::profile::ProjectProfile;
use crate::wiki::exhaustive::top_down::ProjectInsight;

/// Generate architecture documentation from top-down insights
pub struct ArchitectureDocGenerator;

impl ArchitectureDocGenerator {
    /// Generate architecture.md from ProjectInsights
    pub fn generate_architecture_md(
        profile: &ProjectProfile,
        insights: &[ProjectInsight],
    ) -> String {
        let mut content = String::new();

        content.push_str(&format!("# {} Architecture\n\n", profile.name));

        // Overview section
        if !profile.purposes.is_empty() {
            content.push_str("## Overview\n\n");
            content.push_str(&format!("**Purpose:** {}\n\n", profile.purposes.join(", ")));
        }

        if !profile.technical_traits.is_empty() {
            content.push_str(&format!(
                "**Technical Traits:** {}\n\n",
                profile.technical_traits.join(", ")
            ));
        }

        // Architecture pattern section
        for insight in insights {
            if insight.agent == "architecture" {
                if let Some(pattern) = &insight.architecture_pattern {
                    content.push_str("## Architecture Pattern\n\n");
                    content.push_str(&format!("{}\n\n", pattern));
                }

                // Layers section
                if !insight.layers.is_empty() {
                    content.push_str("## Layers\n\n");
                    content.push_str("```mermaid\nflowchart TB\n");
                    for (i, layer) in insight.layers.iter().enumerate() {
                        content.push_str(&format!("    L{}[{}]\n", i, layer.name));
                        if i > 0 {
                            content.push_str(&format!("    L{} --> L{}\n", i - 1, i));
                        }
                    }
                    content.push_str("```\n\n");

                    for layer in &insight.layers {
                        content.push_str(&format!("### {}\n\n", layer.name));

                        if !layer.files.is_empty() {
                            content.push_str("**Files:**\n");
                            for file in &layer.files {
                                content.push_str(&format!("- `{}`\n", file));
                            }
                            content.push('\n');
                        }

                        if !layer.dependencies.is_empty() {
                            content.push_str("**Dependencies:**\n");
                            for dep in &layer.dependencies {
                                content.push_str(&format!("- {}\n", dep));
                            }
                            content.push('\n');
                        }
                    }
                }

                // Boundary violations
                if !insight.boundary_violations.is_empty() {
                    content.push_str("## Boundary Violations\n\n");
                    content.push_str("> Architectural boundary violations detected:\n\n");
                    for violation in &insight.boundary_violations {
                        content.push_str(&format!(
                            "### {} â†’ {}\n\n",
                            violation.from_layer, violation.to_layer
                        ));
                        content.push_str(&format!("**File:** `{}`\n\n", violation.file));
                        content.push_str(&format!("{}\n\n", violation.description));
                    }
                }

                // Architecture diagram
                if let Some(diagram) = &insight.architecture_diagram {
                    content.push_str("## System Diagram\n\n");
                    content.push_str(&format!("```mermaid\n{}\n```\n\n", diagram));
                }
            }
        }

        // Footer
        content.push_str("---\n\n");
        content.push_str("*Generated by WeaveWiki*\n");

        content
    }

    /// Generate risks.md from Risk agent insights
    pub fn generate_risks_md(profile: &ProjectProfile, insights: &[ProjectInsight]) -> String {
        let mut content = String::new();

        content.push_str(&format!("# {} Risk Analysis\n\n", profile.name));

        for insight in insights {
            if insight.agent == "risk" {
                // Risk map
                if !insight.risk_map.is_empty() {
                    content.push_str("## Risk Areas\n\n");
                    content.push_str("| Area | Risk Level | Files | Evidence |\n");
                    content.push_str("|------|------------|-------|----------|\n");
                    for risk in &insight.risk_map {
                        let files_str = if risk.files.len() > 3 {
                            format!("{} files", risk.files.len())
                        } else {
                            risk.files.join(", ")
                        };
                        let evidence_str = if risk.evidence.is_empty() {
                            "-".to_string()
                        } else {
                            risk.evidence.first().unwrap_or(&String::new()).clone()
                        };
                        content.push_str(&format!(
                            "| {} | {:?} | {} | {} |\n",
                            risk.area, risk.risk_level, files_str, evidence_str
                        ));
                    }
                    content.push('\n');

                    // Detailed risk breakdown
                    content.push_str("### Detailed Analysis\n\n");
                    for risk in &insight.risk_map {
                        content.push_str(&format!("#### {}\n\n", risk.area));
                        content.push_str(&format!("**Risk Level:** {:?}\n\n", risk.risk_level));

                        if !risk.files.is_empty() {
                            content.push_str("**Affected Files:**\n");
                            for file in risk.files.iter().take(10) {
                                content.push_str(&format!("- `{}`\n", file));
                            }
                            if risk.files.len() > 10 {
                                content.push_str(&format!(
                                    "- *...and {} more*\n",
                                    risk.files.len() - 10
                                ));
                            }
                            content.push('\n');
                        }

                        if !risk.evidence.is_empty() {
                            content.push_str("**Evidence:**\n");
                            for evidence in &risk.evidence {
                                content.push_str(&format!("- {}\n", evidence));
                            }
                            content.push('\n');
                        }
                    }
                }

                // Cross-cutting risks
                if !insight.cross_cutting_risks.is_empty() {
                    content.push_str("## Cross-Cutting Risks\n\n");
                    content.push_str("> Risks that span multiple areas of the codebase:\n\n");
                    for risk in &insight.cross_cutting_risks {
                        content.push_str(&format!("### {}\n\n", risk.name));
                        content.push_str(&format!(
                            "**Affected Areas:** {}\n\n",
                            risk.affected_areas.join(", ")
                        ));
                        if let Some(mitigation) = &risk.mitigation {
                            content
                                .push_str(&format!("**Mitigation Strategy:** {}\n\n", mitigation));
                        }
                    }
                }

                // Modification hotspots
                if !insight.modification_hotspots.is_empty() {
                    content.push_str("## Modification Hotspots\n\n");
                    content
                        .push_str("> Files with high change complexity or cascading impact:\n\n");
                    for hotspot in &insight.modification_hotspots {
                        content.push_str(&format!("### `{}`\n\n", hotspot.file));
                        content.push_str(&format!("**Reason:** {}\n\n", hotspot.reason));

                        if !hotspot.dependents.is_empty() {
                            content.push_str(&format!(
                                "**Impact:** Changes to this file affect {} dependent files\n\n",
                                hotspot.dependents.len()
                            ));
                            content.push_str("<details>\n<summary>Show dependents</summary>\n\n");
                            for dep in hotspot.dependents.iter().take(20) {
                                content.push_str(&format!("- `{}`\n", dep));
                            }
                            if hotspot.dependents.len() > 20 {
                                content.push_str(&format!(
                                    "- *...and {} more*\n",
                                    hotspot.dependents.len() - 20
                                ));
                            }
                            content.push_str("\n</details>\n\n");
                        }
                    }
                }
            }
        }

        // Footer
        content.push_str("---\n\n");
        content.push_str("*Generated by WeaveWiki*\n");

        content
    }

    /// Generate flows.md from Flow agent insights
    pub fn generate_flows_md(profile: &ProjectProfile, insights: &[ProjectInsight]) -> String {
        let mut content = String::new();

        content.push_str(&format!("# {} Data Flows\n\n", profile.name));

        for insight in insights {
            if insight.agent == "flow" {
                // Business flows
                if !insight.business_flows.is_empty() {
                    content.push_str("## Business Flows\n\n");
                    for flow in &insight.business_flows {
                        content.push_str(&format!("### {}\n\n", flow.name));

                        if !flow.steps.is_empty() {
                            content.push_str("**Steps:**\n");
                            for (i, step) in flow.steps.iter().enumerate() {
                                content.push_str(&format!("{}. {}\n", i + 1, step));
                            }
                            content.push('\n');
                        }

                        if let Some(diagram) = &flow.diagram {
                            content.push_str(&format!("```mermaid\n{}\n```\n\n", diagram));
                        }
                    }
                }

                // Event flows
                if !insight.event_flows.is_empty() {
                    content.push_str("## Event Flows\n\n");
                    for flow in &insight.event_flows {
                        content.push_str(&format!("### {}\n\n", flow.name));

                        if !flow.events.is_empty() {
                            content.push_str("**Events:**\n");
                            for event in &flow.events {
                                content.push_str(&format!("- {}\n", event));
                            }
                            content.push('\n');
                        }

                        if !flow.handlers.is_empty() {
                            content.push_str("**Handlers:**\n");
                            for handler in &flow.handlers {
                                content.push_str(&format!("- `{}`\n", handler));
                            }
                            content.push('\n');
                        }
                    }
                }

                // Data pipelines
                if !insight.data_pipelines.is_empty() {
                    content.push_str("## Data Pipelines\n\n");
                    for pipeline in &insight.data_pipelines {
                        content.push_str(&format!("### {}\n\n", pipeline.name));

                        if let Some(source) = &pipeline.source {
                            content.push_str(&format!("**Source:** {}\n", source));
                        }
                        if let Some(destination) = &pipeline.destination {
                            content.push_str(&format!("**Destination:** {}\n", destination));
                        }
                        content.push('\n');

                        if !pipeline.stages.is_empty() {
                            content.push_str("**Pipeline Stages:**\n\n");
                            content.push_str("```mermaid\nflowchart LR\n");
                            for (i, stage) in pipeline.stages.iter().enumerate() {
                                let sanitized = stage.replace('[', "(").replace(']', ")");
                                content.push_str(&format!("    S{}[\"{}\"]\n", i, sanitized));
                                if i > 0 {
                                    content.push_str(&format!("    S{} --> S{}\n", i - 1, i));
                                }
                            }
                            content.push_str("```\n\n");
                        }
                    }
                }
            }
        }

        // Footer
        content.push_str("---\n\n");
        content.push_str("*Generated by WeaveWiki*\n");

        content
    }

    /// Generate terminology.md from Domain agent insights
    pub fn generate_terminology_md(
        profile: &ProjectProfile,
        insights: &[ProjectInsight],
    ) -> String {
        let mut content = String::new();

        content.push_str(&format!("# {} Domain Terminology\n\n", profile.name));

        // Profile-level terminology
        if !profile.terminology.is_empty() {
            content.push_str("## Core Terms\n\n");
            content.push_str("> Terms identified during project characterization:\n\n");

            // Sort by term name
            let mut terms = profile.terminology.clone();
            terms.sort_by(|a, b| a.term.cmp(&b.term));

            for term in &terms {
                content.push_str(&format!("### {}\n\n", term.term));
                content.push_str(&format!("{}\n\n", term.definition));
            }
        }

        // Domain agent terminology
        for insight in insights {
            if insight.agent == "domain" && !insight.domain_terminology.is_empty() {
                content.push_str("## Additional Terms\n\n");
                content.push_str("> Terms discovered during domain analysis:\n\n");

                let mut terms = insight.domain_terminology.clone();
                terms.sort_by(|a, b| a.term.cmp(&b.term));

                for term in &terms {
                    content.push_str(&format!("### {}\n\n", term.term));
                    content.push_str(&format!("{}\n\n", term.definition));
                }
            }

            // Domain patterns
            if insight.agent == "domain" && !insight.domain_patterns.is_empty() {
                content.push_str("## Domain Patterns\n\n");
                for pattern in &insight.domain_patterns {
                    content.push_str(&format!("- {}\n", pattern));
                }
                content.push('\n');
            }

            // Domain recommendations
            if insight.agent == "domain" && !insight.domain_recommendations.is_empty() {
                content.push_str("## Recommendations\n\n");
                for rec in &insight.domain_recommendations {
                    content.push_str(&format!("- {}\n", rec));
                }
                content.push('\n');
            }
        }

        // Footer
        content.push_str("---\n\n");
        content.push_str("*Generated by WeaveWiki*\n");

        content
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::{AnalysisMode, ProjectScale};
    use crate::types::DomainTerm;
    use crate::wiki::exhaustive::top_down::insights::{
        BoundaryViolation, BusinessFlow, CrossCuttingRisk, DataPipeline, EventFlow, Layer,
        ModificationHotspot, RiskArea,
    };
    use crate::wiki::exhaustive::types::Importance;

    #[test]
    fn test_generate_architecture_md() {
        let profile = ProjectProfile::new(
            "TestProject".to_string(),
            ProjectScale::Medium,
            AnalysisMode::Standard,
        );

        let mut insight = ProjectInsight::new("architecture");
        insight.architecture_pattern = Some("Layered Architecture".to_string());
        insight.layers = vec![
            Layer {
                name: "API Layer".to_string(),
                files: vec!["src/api/mod.rs".to_string()],
                dependencies: vec!["Service Layer".to_string()],
            },
            Layer {
                name: "Service Layer".to_string(),
                files: vec!["src/service/mod.rs".to_string()],
                dependencies: vec!["Data Layer".to_string()],
            },
        ];
        insight.boundary_violations = vec![BoundaryViolation {
            from_layer: "API Layer".to_string(),
            to_layer: "Data Layer".to_string(),
            file: "src/api/handler.rs".to_string(),
            description: "Direct database access".to_string(),
        }];

        let md = ArchitectureDocGenerator::generate_architecture_md(&profile, &[insight]);

        assert!(md.contains("# TestProject Architecture"));
        assert!(md.contains("## Architecture Pattern"));
        assert!(md.contains("Layered Architecture"));
        assert!(md.contains("## Layers"));
        assert!(md.contains("API Layer"));
        assert!(md.contains("Service Layer"));
        assert!(md.contains("## Boundary Violations"));
    }

    #[test]
    fn test_generate_risks_md() {
        let profile = ProjectProfile::new(
            "TestProject".to_string(),
            ProjectScale::Medium,
            AnalysisMode::Standard,
        );

        let mut insight = ProjectInsight::new("risk");
        insight.risk_map = vec![RiskArea {
            area: "Authentication".to_string(),
            risk_level: Importance::High,
            files: vec!["src/auth.rs".to_string()],
            evidence: vec!["No rate limiting".to_string()],
        }];
        insight.cross_cutting_risks = vec![CrossCuttingRisk {
            name: "Error Handling".to_string(),
            affected_areas: vec!["API".to_string(), "Service".to_string()],
            mitigation: Some("Implement consistent error handling".to_string()),
        }];
        insight.modification_hotspots = vec![ModificationHotspot {
            file: "src/core.rs".to_string(),
            reason: "High coupling".to_string(),
            dependents: vec!["src/api.rs".to_string(), "src/service.rs".to_string()],
        }];

        let md = ArchitectureDocGenerator::generate_risks_md(&profile, &[insight]);

        assert!(md.contains("# TestProject Risk Analysis"));
        assert!(md.contains("## Risk Areas"));
        assert!(md.contains("Authentication"));
        assert!(md.contains("## Cross-Cutting Risks"));
        assert!(md.contains("Error Handling"));
        assert!(md.contains("## Modification Hotspots"));
    }

    #[test]
    fn test_generate_flows_md() {
        let profile = ProjectProfile::new(
            "TestProject".to_string(),
            ProjectScale::Medium,
            AnalysisMode::Standard,
        );

        let mut insight = ProjectInsight::new("flow");
        insight.business_flows = vec![BusinessFlow {
            name: "User Registration".to_string(),
            steps: vec![
                "Validate input".to_string(),
                "Create user".to_string(),
                "Send email".to_string(),
            ],
            diagram: Some("flowchart TD\nA[Start]-->B[End]".to_string()),
        }];
        insight.event_flows = vec![EventFlow {
            name: "Order Created".to_string(),
            events: vec!["order.created".to_string()],
            handlers: vec!["handle_order_created".to_string()],
        }];
        insight.data_pipelines = vec![DataPipeline {
            name: "Analytics Pipeline".to_string(),
            stages: vec![
                "Collect".to_string(),
                "Transform".to_string(),
                "Store".to_string(),
            ],
            source: Some("API Events".to_string()),
            destination: Some("Database".to_string()),
        }];

        let md = ArchitectureDocGenerator::generate_flows_md(&profile, &[insight]);

        assert!(md.contains("# TestProject Data Flows"));
        assert!(md.contains("## Business Flows"));
        assert!(md.contains("User Registration"));
        assert!(md.contains("## Event Flows"));
        assert!(md.contains("Order Created"));
        assert!(md.contains("## Data Pipelines"));
        assert!(md.contains("Analytics Pipeline"));
    }

    #[test]
    fn test_generate_terminology_md() {
        let mut profile = ProjectProfile::new(
            "TestProject".to_string(),
            ProjectScale::Medium,
            AnalysisMode::Standard,
        );
        profile.terminology = vec![DomainTerm::new("Widget", "A reusable component")];

        let mut insight = ProjectInsight::new("domain");
        insight.domain_terminology = vec![DomainTerm::new("Factory", "Creates widgets")];
        insight.domain_patterns = vec!["Singleton pattern for factories".to_string()];
        insight.domain_recommendations = vec!["Use dependency injection".to_string()];

        let md = ArchitectureDocGenerator::generate_terminology_md(&profile, &[insight]);

        assert!(md.contains("# TestProject Domain Terminology"));
        assert!(md.contains("## Core Terms"));
        assert!(md.contains("### Widget"));
        assert!(md.contains("## Additional Terms"));
        assert!(md.contains("### Factory"));
        assert!(md.contains("## Domain Patterns"));
        assert!(md.contains("## Recommendations"));
    }
}
